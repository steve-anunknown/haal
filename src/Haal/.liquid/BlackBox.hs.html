<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>src/Haal/BlackBox.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='syntax.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum>  1: </span><a class=annot href="#"><span class=annottext>GHC.Types.Module</span><span class='hs-comment'>{-# LANGUAGE ConstraintKinds #-}</span></a>
<span class=hs-linenum>  2: </span><span class='hs-comment'>{-# LANGUAGE FunctionalDependencies #-}</span>
<span class=hs-linenum>  3: </span><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class=hs-linenum>  4: </span>
<span class=hs-linenum>  5: </span><span class='hs-comment'>{- | This module defines the BlackBox type class as well as the Automaton and SUL
sub classes.
-}</span>
<span class=hs-linenum>  8: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Haal.BlackBox</span> <span class='hs-layout'>(</span>
<span class=hs-linenum>  9: </span>    <span class='hs-conid'>Automaton</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 10: </span>    <span class='hs-conid'>SUL</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 11: </span>    <span class='hs-conid'>StateID</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 12: </span>    <span class='hs-conid'>Finite</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 13: </span>    <span class='hs-conid'>FiniteEq</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 14: </span>    <span class='hs-conid'>FiniteOrd</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 15: </span>    <span class='hs-varid'>inputs</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 16: </span>    <span class='hs-varid'>outputs</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 17: </span>    <span class='hs-varid'>walk</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 18: </span>    <span class='hs-varid'>initial</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 19: </span>    <span class='hs-varid'>distinguish</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 20: </span>    <span class='hs-varid'>accessSequences</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 21: </span>    <span class='hs-varid'>localCharacterizingSet</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 22: </span>    <span class='hs-varid'>globalCharacterizingSet</span><span class='hs-layout'>,</span>
<span class=hs-linenum> 23: </span><span class='hs-layout'>)</span>
<span class=hs-linenum> 24: </span><span class='hs-keyword'>where</span>
<span class=hs-linenum> 25: </span>
<span class=hs-linenum> 26: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Bifunctor</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Bif</span>
<span class=hs-linenum> 27: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.List</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>List</span>
<span class=hs-linenum> 28: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Map</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Map</span>
<span class=hs-linenum> 29: </span><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Set</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Set</span>
<span class=hs-linenum> 30: </span>
<span class=hs-linenum> 31: </span><span class='hs-comment'>{- | The 'StateID' type is an alias for an integer that represents the state of the automaton.
 - It is used as a default type for the state of learned automata.
-}</span>
<span class=hs-linenum> 34: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>StateID</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum> 35: </span>
<span class=hs-linenum> 36: </span><span class='hs-comment'>{- | The 'SUL' type class defines the basic interface for a black box automaton.
It provides methods to step through the automaton, walk through a list of inputs,
and retrieve the current state.
-}</span>
<span class=hs-linenum> 40: </span><span class='hs-keyword'>class</span> <span class='hs-conid'>SUL</span> <span class='hs-varid'>sul</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 41: </span>    <span class='hs-varid'>step</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span><span class='hs-layout'>,</span> <span class='hs-varid'>o</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 42: </span>    <span class='hs-varid'>reset</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span>
<span class=hs-linenum> 43: </span>
<span class=hs-linenum> 44: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>Finite</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Enum</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bounded</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 45: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>FiniteEq</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-conid'>Finite</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 46: </span><span class='hs-keyword'>type</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ord</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-conid'>Finite</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 47: </span>
<span class=hs-linenum> 48: </span><span class='hs-definition'>walk</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>SUL</span> <span class='hs-varid'>sul</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>o</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 49: </span><a class=annot href="#"><span class=annottext>forall a b c .
(Haal.BlackBox.SUL&lt;[]&gt; a) =&gt;
a b c -&gt; [b] -&gt; (a b c, [c])</span><span class='hs-definition'>walk</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>List.mapAccumL</span> <a class=annot href="#"><span class=annottext>forall a b . c a b -&gt; a -&gt; (c a b, b)</span><span class='hs-varid'>step</span></a>
<span class=hs-linenum> 50: </span>
<span class=hs-linenum> 51: </span><span class='hs-definition'>inputs</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set.Set</span> <span class='hs-varid'>i</span>
<span class=hs-linenum> 52: </span><a class=annot href="#"><span class=annottext>forall a b c .
(GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord a) ((GHC.Enum.Enum a), (GHC.Enum.Bounded a))) =&gt;
b a c -&gt; (Data.Set.Internal.Set a)</span><span class='hs-definition'>inputs</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set.fromList</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>minBound</span></a> <span class='hs-keyglyph'>..</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>maxBound</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 53: </span>
<span class=hs-linenum> 54: </span><span class='hs-definition'>outputs</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>o</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>sul</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set.Set</span> <span class='hs-varid'>o</span>
<span class=hs-linenum> 55: </span><a class=annot href="#"><span class=annottext>forall a b c .
(GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord a) ((GHC.Enum.Enum a), (GHC.Enum.Bounded a))) =&gt;
b c a -&gt; (Data.Set.Internal.Set a)</span><span class='hs-definition'>outputs</span></a> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Set.fromList</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>minBound</span></a> <span class='hs-keyglyph'>..</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>maxBound</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 56: </span>
<span class=hs-linenum> 57: </span><span class='hs-comment'>{- | The 'Automaton' type class extends the 'SUL' type class and adds
support for automata operations.
-}</span>
<span class=hs-linenum> 60: </span><span class='hs-keyword'>class</span> <span class='hs-layout'>(</span><span class='hs-conid'>SUL</span> <span class='hs-varid'>aut</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Automaton</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>st</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>aut</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>st</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 61: </span>    <span class='hs-varid'>transitions</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum> 62: </span>        <span class='hs-layout'>(</span><span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>st</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<span class=hs-linenum> 63: </span>        <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 64: </span>        <span class='hs-conid'>Map.Map</span> <span class='hs-layout'>(</span><span class='hs-varid'>st</span><span class='hs-layout'>,</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>st</span><span class='hs-layout'>,</span> <span class='hs-varid'>o</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 65: </span>    <span class='hs-varid'>states</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>st</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set.Set</span> <span class='hs-varid'>st</span>
<span class=hs-linenum> 66: </span>    <span class='hs-varid'>current</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>st</span>
<span class=hs-linenum> 67: </span>    <span class='hs-varid'>update</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>st</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span>
<span class=hs-linenum> 68: </span>
<span class=hs-linenum> 69: </span><span class='hs-definition'>initial</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Automaton</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>st</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>st</span>
<span class=hs-linenum> 70: </span><a class=annot href="#"><span class=annottext>forall a b c d . (Haal.BlackBox.Automaton&lt;[]&gt; a b) =&gt; a c d -&gt; b</span><span class='hs-definition'>initial</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b . c a b -&gt; d</span><span class='hs-varid'>current</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>forall a b . c a b -&gt; c a b</span><span class='hs-varid'>reset</span></a>
<span class=hs-linenum> 71: </span>
<span class=hs-linenum> 72: </span><span class='hs-comment'>-- Starts a bfs from the initial state and finds all reachable states</span>
<span class=hs-linenum> 73: </span><span class='hs-definition'>findReachable</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Automaton</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>st</span><span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>st</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set.Set</span> <span class='hs-varid'>st</span>
<span class=hs-linenum> 74: </span><a class=annot href="#"><span class=annottext>forall a b c d .
(Haal.BlackBox.Automaton&lt;[]&gt; a b, GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord c) ((GHC.Enum.Enum c), (GHC.Enum.Bounded c)), GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord b) ((GHC.Enum.Enum b), (GHC.Enum.Bounded b))) =&gt;
a c d -&gt; (Data.Set.Internal.Set b)</span><span class='hs-definition'>findReachable</span></a> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>automaton</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 75: </span>    <span class='hs-keyword'>let</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>initialState</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>initial</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == automaton##a2ar}</span><span class='hs-varid'>automaton</span></a>
<span class=hs-linenum> 76: </span>        <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>alphabet</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>inputs</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == automaton##a2ar}</span><span class='hs-varid'>automaton</span></a>
<span class=hs-linenum> 77: </span>        <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a) -&gt; [a] -&gt; (Data.Set.Internal.Set a)</span><span class='hs-varid'>bfs</span></a> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>visited</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>queue</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum> 78: </span>            <span class='hs-keyword'>case</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == queue##a2aw
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>queue</span></a> <span class='hs-keyword'>of</span>
<span class=hs-linenum> 79: </span>                <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == visited##a2av}</span><span class='hs-varid'>visited</span></a>
<span class=hs-linenum> 80: </span>                <span class='hs-layout'>(</span><span class='hs-varid'>curr</span> <span class='hs-conop'>:</span> <span class='hs-varid'>queue'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 81: </span>                    <span class='hs-keyword'>let</span> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>mo</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>update</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == automaton##a2ar}</span><span class='hs-varid'>automaton</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == curr##a2ax}</span><span class='hs-varid'>curr</span></a>
<span class=hs-linenum> 82: </span>                        <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>nextStates</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-conid'>Set.map</span></a> <a class=annot href="#"><span class=annottext>a -&gt; b</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>forall a b . c a b -&gt; d</span><span class='hs-varid'>current</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      x1:(a, b) -&gt; {VV : a | VV == fst x1} | VV == fst}</span><span class='hs-varid'>fst</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>a -&gt; (b a c, c)</span><span class='hs-varid'>step</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == mo##a2az}</span><span class='hs-varid'>mo</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == alphabet##a2at}</span><span class='hs-varid'>alphabet</span></a>
<span class=hs-linenum> 83: </span>                        <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == Set_cup visited##a2av nextStates##a2aA}</span><span class='hs-varid'>newVisited</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == Set_cup visited##a2av nextStates##a2aA}</span><span class='hs-conid'>Set.union</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == visited##a2av}</span><span class='hs-varid'>visited</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == nextStates##a2aA}</span><span class='hs-varid'>nextStates</span></a>
<span class=hs-linenum> 84: </span>                        <span class='hs-comment'>-- Efficient queue management with a Set for fast membership checking</span>
<span class=hs-linenum> 85: </span>                        <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>newQueue</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-conid'>Set.toList</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == Set_dif nextStates##a2aA visited##a2av}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Set.difference</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == nextStates##a2aA}</span><span class='hs-varid'>nextStates</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == visited##a2av}</span><span class='hs-varid'>visited</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == queue'##a2ay
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>queue'</span></a>
<span class=hs-linenum> 86: </span>                     <span class='hs-keyword'>in</span> <span class='hs-varid'>bfs</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == newVisited##a2aB
                                 &amp;&amp; v == Set_cup visited##a2av nextStates##a2aA}</span><span class='hs-varid'>newVisited</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == newQueue##a2aC
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>newQueue</span></a>
<span class=hs-linenum> 87: </span>     <span class='hs-keyword'>in</span> <span class='hs-varid'>bfs</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == Set_sng initialState##a2as}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Set.singleton</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == initialState##a2as}</span><span class='hs-varid'>initialState</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | head v == initialState##a2as}</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == initialState##a2as}</span><span class='hs-varid'>initialState</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 88: </span>
<span class=hs-linenum> 89: </span><span class='hs-comment'>-- | Returns a map containing the shortest sequence to access each reachable state from the initial state.</span>
<span class=hs-linenum> 90: </span><span class='hs-definition'>accessSequences</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum> 91: </span>    <span class='hs-keyword'>forall</span> <span class='hs-varid'>s</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-varid'>aut</span><span class='hs-varop'>.</span>
<span class=hs-linenum> 92: </span>    <span class='hs-layout'>(</span><span class='hs-conid'>Automaton</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<span class=hs-linenum> 93: </span>    <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum> 94: </span>    <span class='hs-conid'>Map.Map</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum> 95: </span><a class=annot href="#"><span class=annottext>forall a b c d .
(Haal.BlackBox.Automaton&lt;[]&gt; d a, GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord b) ((GHC.Enum.Enum b), (GHC.Enum.Bounded b)), GHC.Classes.Ord&lt;[]&gt; a) =&gt;
d b c -&gt; (Data.Map.Internal.Map a [b])</span><span class='hs-definition'>accessSequences</span></a> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>aut</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[(a, [b])] -&gt; (Data.Set.Internal.Set a) -&gt; (Data.Map.Internal.Map a [b]) -&gt; (Data.Map.Internal.Map a [b])</span><span class='hs-varid'>bfs</span></a> <a class=annot href="#"><span class=annottext>[(a, [b])]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : (a, [b]) | fst v == initialSt##a2aF
                &amp;&amp; x_Tuple21 v == initialSt##a2aF}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == initialSt##a2aF}</span><span class='hs-varid'>initialSt</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | Set_emp (listElts v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == Set_sng initialSt##a2aF}</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Set.singleton</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == initialSt##a2aF}</span><span class='hs-varid'>initialSt</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map a [b])</span><span class='hs-layout'>(</span></a><span class='hs-conid'>Map.singleton</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == initialSt##a2aF}</span><span class='hs-varid'>initialSt</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | Set_emp (listElts v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 96: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum> 97: </span>    <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>alphabet</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-conid'>Set.toList</span></a> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>inputs</span> <a class=annot href="#"><span class=annottext>{v : a b c | v == aut##a2aD}</span><span class='hs-varid'>aut</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum> 98: </span>    <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>initialSt</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>initial</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == aut##a2aD}</span><span class='hs-varid'>aut</span></a>
<span class=hs-linenum> 99: </span>
<span class=hs-linenum>100: </span>    <span class='hs-varid'>bfs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Set.Set</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map.Map</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Map.Map</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>101: </span>    <a class=annot href="#"><span class=annottext>[(a, [b])] -&gt; (Data.Set.Internal.Set a) -&gt; (Data.Map.Internal.Map a [b]) -&gt; (Data.Map.Internal.Map a [b])</span><span class='hs-varid'>bfs</span></a> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map a [b])</span><span class='hs-varid'>acc</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:[a] -&gt; {v : [a] | len v == len x1}</span><span class='hs-conid'>Map.map</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:[a] -&gt; {v : [a] | len v == len x1} | VV == reverse}</span><span class='hs-conid'>List.reverse</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Map.Internal.Map a [b]) | v == acc##a2aH}</span><span class='hs-varid'>acc</span></a>
<span class=hs-linenum>102: </span>    <span class='hs-varid'>bfs</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>prefix</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-varid'>visited</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>103: </span>        <a class=annot href="#"><span class=annottext>[(a, [b])] -&gt; (Data.Set.Internal.Set a) -&gt; (Data.Map.Internal.Map a [b]) -&gt; (Data.Map.Internal.Map a [b])</span><span class='hs-varid'>bfs</span></a> <a class=annot href="#"><span class=annottext>{v : [(a, [b])] | len v == len rest##a2aJ + len newQueue##a2aQ}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : [(a, [b])] | v == rest##a2aJ
                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>rest</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>{v : [(a, [b])] | v == newQueue##a2aQ
                  &amp;&amp; v == successors##a2aN
                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>newQueue</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (Data.Set.Internal.Set a) | v == newVisited##a2aP}</span><span class='hs-varid'>newVisited</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Map.Internal.Map a [b]) | v == newMap##a2aO}</span><span class='hs-varid'>newMap</span></a>
<span class=hs-linenum>104: </span>      <span class='hs-keyword'>where</span>
<span class=hs-linenum>105: </span>        <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>mo</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(a b c, [c]) -&gt; {v : a b c | v == fst x1}</span><span class='hs-varid'>fst</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(a b c, [c])</span><span class='hs-varid'>walk</span></a> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-layout'>(</span></a><span class='hs-varid'>reset</span> <a class=annot href="#"><span class=annottext>{v : a b c | v == aut##a2aD}</span><span class='hs-varid'>aut</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | len v == len prefix##a2aI}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>reverse</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == prefix##a2aI
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>prefix</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>106: </span>        <a class=annot href="#"><span class=annottext>[(a, [b])]</span><span class='hs-varid'>successors</span></a> <span class='hs-keyglyph'>=</span>
<span class=hs-linenum>107: </span>            <span class='hs-keyglyph'>[</span> <a class=annot href="#"><span class=annottext>{v : (a, [b]) | fst v == nextState##a2aS
                &amp;&amp; x_Tuple21 v == nextState##a2aS}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == nextState##a2aS}</span><span class='hs-varid'>nextState</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>input</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == prefix##a2aI
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>prefix</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>108: </span>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>input</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == alphabet##a2aE
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>alphabet</span></a>
<span class=hs-linenum>109: </span>            <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>nextState</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>forall a b . c a b -&gt; d</span><span class='hs-varid'>current</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      x1:(a, b) -&gt; {VV : a | VV == fst x1} | VV == fst}</span><span class='hs-varid'>fst</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(a b c, c)</span><span class='hs-varid'>step</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == mo##a2aM}</span><span class='hs-varid'>mo</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>input</span></a>
<span class=hs-linenum>110: </span>            <span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == nextState##a2aS}</span><span class='hs-varid'>nextState</span></a> <span class='hs-varop'>`Set.notMember`</span> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>visited</span></a>
<span class=hs-linenum>111: </span>            <span class='hs-keyglyph'>]</span>
<span class=hs-linenum>112: </span>
<span class=hs-linenum>113: </span>        <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map a [b])</span><span class='hs-varid'>newMap</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map a [b])</span><span class='hs-varid'>foldr</span></a> <a class=annot href="#"><span class=annottext>(a, [b]) -&gt; (Data.Map.Internal.Map a [b]) -&gt; (Data.Map.Internal.Map a [b])</span><span class='hs-layout'>(</span></a><span class='hs-varid'>uncurry</span> <a class=annot href="#"><span class=annottext>a -&gt; [b] -&gt; (Data.Map.Internal.Map a [b]) -&gt; (Data.Map.Internal.Map a [b])</span><span class='hs-conid'>Map.insert</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : (Data.Map.Internal.Map a [b]) | v == acc##a2aH}</span><span class='hs-varid'>acc</span></a> <a class=annot href="#"><span class=annottext>{v : [(a, [b])] | v == successors##a2aN
                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>successors</span></a>
<span class=hs-linenum>114: </span>        <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>newVisited</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>foldr</span></a> <a class=annot href="#"><span class=annottext>(a, [b]) -&gt; (Data.Set.Internal.Set a) -&gt; (Data.Set.Internal.Set a)</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>x1:a -&gt; x2:(Data.Set.Internal.Set a) -&gt; {v : (Data.Set.Internal.Set a) | v == Set_cup x2 (Set_sng x1)}</span><span class='hs-conid'>Set.insert</span></a> <span class='hs-varop'>.</span> <a class=annot href="#"><span class=annottext>{VV : forall a b .
      x1:(a, b) -&gt; {VV : a | VV == fst x1} | VV == fst}</span><span class='hs-varid'>fst</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>visited</span></a> <a class=annot href="#"><span class=annottext>{v : [(a, [b])] | v == successors##a2aN
                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>successors</span></a>
<span class=hs-linenum>115: </span>        <a class=annot href="#"><span class=annottext>{v : [(a, [b])] | v == successors##a2aN
                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>newQueue</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [(a, [b])] | v == successors##a2aN
                  &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>successors</span></a>
<span class=hs-linenum>116: </span>
<span class=hs-linenum>117: </span><span class='hs-definition'>distinguish</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum>118: </span>    <span class='hs-layout'>(</span> <span class='hs-conid'>Automaton</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>s</span>
<span class=hs-linenum>119: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span>
<span class=hs-linenum>120: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>s</span>
<span class=hs-linenum>121: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>o</span>
<span class=hs-linenum>122: </span>    <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<span class=hs-linenum>123: </span>    <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>124: </span>    <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>125: </span>    <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>126: </span>    <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>127: </span><a class=annot href="#"><span class=annottext>forall a b c d .
(Haal.BlackBox.Automaton&lt;[]&gt; a b, GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord c) ((GHC.Enum.Enum c), (GHC.Enum.Bounded c)), GHC.Classes.Ord&lt;[]&gt; b, GHC.Classes.Eq&lt;[]&gt; d) =&gt;
a c d -&gt; b -&gt; b -&gt; [c]</span><span class='hs-definition'>distinguish</span></a> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>m</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>s1</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>s2</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b])</span><span class='hs-varid'>explore</span></a> <a class=annot href="#"><span class=annottext>{VV : forall a b . (Data.Map.Internal.Map a b) | VV == empty}</span><span class='hs-conid'>Map.empty</span></a> <a class=annot href="#"><span class=annottext>[(a, a, [b])]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : (a, a, [b]) | x_Tuple31 v == s1##a2aU
                   &amp;&amp; x_Tuple32 v == s2##a2aV}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == s1##a2aU}</span><span class='hs-varid'>s1</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == s2##a2aV}</span><span class='hs-varid'>s2</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | Set_emp (listElts v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>128: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>129: </span>    <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>alphabet</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-conid'>Set.toList</span></a> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>inputs</span> <a class=annot href="#"><span class=annottext>{v : a b c | v == m##a2aT}</span><span class='hs-varid'>m</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>130: </span>
<span class=hs-linenum>131: </span>    <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b]) -&gt; [(a, a, [b])] -&gt; [b]</span><span class='hs-varid'>explore</span></a> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a &lt;p :: a a -&gt; Bool&gt;.
      {v : [a]&lt;\x3 VV -&gt; {VV : a&lt;p x3&gt; | true}&gt; | Set_emp (listElts v)
                                                  &amp;&amp; len v == 0} | VV == []}</span><span class='hs-conid'>[]</span></a>
<span class=hs-linenum>132: </span>    <span class='hs-varid'>explore</span> <span class='hs-varid'>visited</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>q1</span><span class='hs-layout'>,</span> <span class='hs-varid'>q2</span><span class='hs-layout'>,</span> <span class='hs-varid'>prefix</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>queue</span><span class='hs-layout'>)</span>
<span class=hs-linenum>133: </span>        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>seqFound</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Maybe.Maybe a) | v == discrepancy##a2bb}</span><span class='hs-varid'>discrepancy</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:[a] -&gt; {v : [a] | len v == len x1} | VV == reverse}</span><span class='hs-varid'>reverse</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | head v == seqFound##a2bj
           &amp;&amp; len v == 1 + len prefix##a2b2
           &amp;&amp; listElts v == Set_cup (Set_sng seqFound##a2bj) (listElts prefix##a2b2)
           &amp;&amp; tail v == prefix##a2b2}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == seqFound##a2bj}</span><span class='hs-varid'>seqFound</span></a> <span class='hs-conop'>:</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == prefix##a2b2
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>prefix</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>134: </span>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b]) -&gt; [(a, a, [b])] -&gt; [b]</span><span class='hs-varid'>explore</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Map.Internal.Map (a, a) [b]) | v == newVisited##a2b4}</span><span class='hs-varid'>newVisited</span></a> <a class=annot href="#"><span class=annottext>{v : [(a, a, [b])] | len v == len queue##a2b3 + len newQueue##a2be}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : [(a, a, [b])] | v == queue##a2b3
                     &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>queue</span></a> <span class='hs-varop'>++</span> <a class=annot href="#"><span class=annottext>{v : [(a, a, [b])] | v == newQueue##a2be
                     &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>newQueue</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>135: </span>      <span class='hs-keyword'>where</span>
<span class=hs-linenum>136: </span>        <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b])</span><span class='hs-varid'>newVisited</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b])</span><span class='hs-conid'>Map.insert</span></a> <a class=annot href="#"><span class=annottext>{v : (a, a) | fst v == q1##a2b0
              &amp;&amp; snd v == q2##a2b1
              &amp;&amp; x_Tuple21 v == q1##a2b0
              &amp;&amp; x_Tuple22 v == q2##a2b1}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == q1##a2b0}</span><span class='hs-varid'>q1</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == q2##a2b1}</span><span class='hs-varid'>q2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == prefix##a2b2
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>prefix</span></a> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b])</span><span class='hs-varid'>visited</span></a>
<span class=hs-linenum>137: </span>        <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>mo1</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>update</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == m##a2aT}</span><span class='hs-varid'>m</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == q1##a2b0}</span><span class='hs-varid'>q1</span></a>
<span class=hs-linenum>138: </span>        <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>mo2</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>update</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == m##a2aT}</span><span class='hs-varid'>m</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == q2##a2b1}</span><span class='hs-varid'>q2</span></a>
<span class=hs-linenum>139: </span>
<span class=hs-linenum>140: </span>        <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>nextStates1</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>outputs1</span></a><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[(a, b)] -&gt; ([a], [b])</span><span class='hs-varid'>unzip</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : [(a, b)] | len v == len alphabet##a2aW}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (b, c)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>stepAndCurrent</span> <a class=annot href="#"><span class=annottext>{v : a b c | v == mo1##a2b5}</span><span class='hs-varid'>mo1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == alphabet##a2aW
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>alphabet</span></a>
<span class=hs-linenum>141: </span>        <span class='hs-layout'>(</span><a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>nextStates2</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>outputs2</span></a><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[(a, b)] -&gt; ([a], [b])</span><span class='hs-varid'>unzip</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : [(a, b)] | len v == len alphabet##a2aW}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>a -&gt; (b, c)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>stepAndCurrent</span> <a class=annot href="#"><span class=annottext>{v : a b c | v == mo2##a2b6}</span><span class='hs-varid'>mo2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == alphabet##a2aW
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>alphabet</span></a>
<span class=hs-linenum>142: </span>
<span class=hs-linenum>143: </span>        <a class=annot href="#"><span class=annottext>(GHC.Maybe.Maybe a)</span><span class='hs-varid'>discrepancy</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>(GHC.Maybe.Maybe GHC.Types.Int)</span><span class='hs-conid'>List.elemIndex</span></a> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Bool | not v
                      &amp;&amp; v == False}</span><span class='hs-conid'>False</span></a> <a class=annot href="#"><span class=annottext>{v : [GHC.Types.Bool] | len v &lt;= len outputs1##a2s0
                        &amp;&amp; len v &lt;= len outputs2##a2rh}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>zipWith</span> <a class=annot href="#"><span class=annottext>x1:a -&gt; x2:a -&gt; {v : GHC.Types.Bool | v &lt;=&gt; x1 == x2}</span><span class='hs-layout'>(</span></a><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == outputs1##a2s0
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>outputs1</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == outputs2##a2rh
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>outputs2</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:a -&gt; {v : (GHC.Maybe.Maybe a) | lqdc##$select##GHC.Maybe.Just##1 v == x1} | VV == Just}</span><span class='hs-keyglyph'>\</span></a><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-varid'>idx</span></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : [a] | v == alphabet##a2aW
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>alphabet</span></a> <span class='hs-varop'>!!</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == idx##a2bf}</span><span class='hs-varid'>idx</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>144: </span>
<span class=hs-linenum>145: </span>        <a class=annot href="#"><span class=annottext>{v : [[a]] | len v == len alphabet##a2aW}</span><span class='hs-varid'>appended</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : [[a]] | len v == len alphabet##a2aW}</span><span class='hs-varid'>map</span></a> <a class=annot href="#"><span class=annottext>v_B2:a -&gt; {v : [a] | head v == v_B2
                     &amp;&amp; len v == 1 + len prefix##a2b2
                     &amp;&amp; listElts v == Set_cup (Set_sng v_B2) (listElts prefix##a2b2)
                     &amp;&amp; tail v == prefix##a2b2}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>[a]</span><span class='hs-conop'>:</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == prefix##a2b2
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>prefix</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == alphabet##a2aW
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>alphabet</span></a>
<span class=hs-linenum>146: </span>
<span class=hs-linenum>147: </span>        <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b])</span><span class='hs-varid'>toBeVisited</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[((a, a), [b])] -&gt; (Data.Map.Internal.Map (a, a) [b])</span><span class='hs-conid'>Map.fromList</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>{v : [((a, a), [b])] | len v &lt;= len appended##a2bc}</span><span class='hs-varid'>zip</span></a> <a class=annot href="#"><span class=annottext>{v : [(a, a)] | (len nextStates1##a2rZ == len nextStates2##a2rg =&gt; len v == len nextStates1##a2rZ)
                &amp;&amp; len v &lt;= len nextStates1##a2rZ
                &amp;&amp; len v &lt;= len nextStates2##a2rg}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>zip</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == nextStates1##a2rZ
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>nextStates1</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == nextStates2##a2rg
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>nextStates2</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [[a]] | v == appended##a2bc
             &amp;&amp; len v == len alphabet##a2aW
             &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>appended</span></a>
<span class=hs-linenum>148: </span>
<span class=hs-linenum>149: </span>        <a class=annot href="#"><span class=annottext>[(a, a, [b])]</span><span class='hs-varid'>newQueue</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>[(a, a, [b])]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>{v : (a, a, [b]) | x_Tuple31 v == s1'##a2bg
                   &amp;&amp; x_Tuple32 v == s2'##a2bh
                   &amp;&amp; x_Tuple33 v == p##a2bi}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == s1'##a2bg}</span><span class='hs-varid'>s1'</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == s2'##a2bh}</span><span class='hs-varid'>s2'</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == p##a2bi
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>p</span></a><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>s1'</span><span class='hs-layout'>,</span> <span class='hs-varid'>s2'</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>[((a, a), [b])]</span><span class='hs-conid'>Map.toList</span></a> <a class=annot href="#"><span class=annottext>{v : (Data.Map.Internal.Map (a, a) [b]) | v == toBeVisited##a2bd}</span><span class='hs-varid'>toBeVisited</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{v : (a, a) | fst v == s1'##a2bg
              &amp;&amp; snd v == s2'##a2bh
              &amp;&amp; x_Tuple21 v == s1'##a2bg
              &amp;&amp; x_Tuple22 v == s2'##a2bh}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == s1'##a2bg}</span><span class='hs-varid'>s1'</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == s2'##a2bh}</span><span class='hs-varid'>s2'</span></a><span class='hs-layout'>)</span> <span class='hs-varop'>`Map.notMember`</span> <a class=annot href="#"><span class=annottext>(Data.Map.Internal.Map (a, a) [b])</span><span class='hs-varid'>visited</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>150: </span>
<span class=hs-linenum>151: </span>    <a class=annot href="#"><span class=annottext>forall a b c d .
(Haal.BlackBox.Automaton&lt;[]&gt; a b) =&gt;
a c d -&gt; c -&gt; (b, d)</span><span class='hs-varid'>stepAndCurrent</span></a> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>mo</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>i</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a b c -&gt; d</span><span class='hs-conid'>Bif.first</span></a> <a class=annot href="#"><span class=annottext>forall a b . c a b -&gt; d</span><span class='hs-varid'>current</span></a> <a class=annot href="#"><span class=annottext>(a b c, c)</span><span class='hs-layout'>(</span></a><span class='hs-varid'>step</span> <a class=annot href="#"><span class=annottext>{v : a b c | v == mo##a2bk}</span><span class='hs-varid'>mo</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == i##a2bl}</span><span class='hs-varid'>i</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>152: </span>
<span class=hs-linenum>153: </span><span class='hs-comment'>{- | Returns a set of lists of inputs that can be used to distinguish between the given state and
 - any other state of the automaton.
-}</span>
<span class=hs-linenum>156: </span><span class='hs-definition'>localCharacterizingSet</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum>157: </span>    <span class='hs-layout'>(</span> <span class='hs-conid'>Automaton</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>s</span>
<span class=hs-linenum>158: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span>
<span class=hs-linenum>159: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>s</span>
<span class=hs-linenum>160: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>o</span>
<span class=hs-linenum>161: </span>    <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<span class=hs-linenum>162: </span>    <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>163: </span>    <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>164: </span>    <span class='hs-conid'>Set.Set</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>165: </span><a class=annot href="#"><span class=annottext>forall a b c d .
(Haal.BlackBox.Automaton&lt;[]&gt; a b, GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord c) ((GHC.Enum.Enum c), (GHC.Enum.Bounded c)), GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord b) ((GHC.Enum.Enum b), (GHC.Enum.Bounded b)), GHC.Classes.Eq&lt;[]&gt; d) =&gt;
a c d -&gt; b -&gt; (Data.Set.Internal.Set [c])</span><span class='hs-definition'>localCharacterizingSet</span></a> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>m</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>s</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Classes.Ord [a]) | v == $dOrd_a2vT}</span><span class='hs-conid'>Set.fromList</span></a> <a class=annot href="#"><span class=annottext>[[a]]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>d</span></a> <a class=annot href="#"><span class=annottext>{VV : a | VV == s##a2bn}</span><span class='hs-varid'>s</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>sx</span></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sx</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>x1:(Data.Set.Internal.Set a) -&gt; {v : [a] | x1 == listElts v}</span><span class='hs-conid'>Set.toList</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>states</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == m##a2bm}</span><span class='hs-varid'>m</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>{VV : a | VV == s##a2bn}</span><span class='hs-varid'>s</span></a> <span class='hs-varop'>/=</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>sx</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>166: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>167: </span>    <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; [b]</span><span class='hs-varid'>d</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; [b]</span><span class='hs-varid'>distinguish</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == m##a2bm}</span><span class='hs-varid'>m</span></a>
<span class=hs-linenum>168: </span>
<span class=hs-linenum>169: </span><span class='hs-comment'>{- | Returns a set of lists of inputs that can be used to distinguish between any two different states
of the automaton.
-}</span>
<span class=hs-linenum>172: </span><span class='hs-definition'>globalCharacterizingSet</span> <span class='hs-keyglyph'>::</span>
<span class=hs-linenum>173: </span>    <span class='hs-layout'>(</span> <span class='hs-conid'>Automaton</span> <span class='hs-varid'>aut</span> <span class='hs-varid'>s</span>
<span class=hs-linenum>174: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>i</span>
<span class=hs-linenum>175: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>FiniteOrd</span> <span class='hs-varid'>s</span>
<span class=hs-linenum>176: </span>    <span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>o</span>
<span class=hs-linenum>177: </span>    <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span>
<span class=hs-linenum>178: </span>    <span class='hs-varid'>aut</span> <span class='hs-varid'>i</span> <span class='hs-varid'>o</span> <span class='hs-keyglyph'>-&gt;</span>
<span class=hs-linenum>179: </span>    <span class='hs-conid'>Set.Set</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>180: </span><a class=annot href="#"><span class=annottext>forall a b c d .
(Haal.BlackBox.Automaton&lt;[]&gt; a b, GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord c) ((GHC.Enum.Enum c), (GHC.Enum.Bounded c)), GHC.Classes.(%,%)&lt;[]&gt; (GHC.Classes.Ord b) ((GHC.Enum.Enum b), (GHC.Enum.Bounded b)), GHC.Classes.Eq&lt;[]&gt; d) =&gt;
a c d -&gt; (Data.Set.Internal.Set [c])</span><span class='hs-definition'>globalCharacterizingSet</span></a> <a class=annot href="#"><span class=annottext>a b c</span><span class='hs-varid'>m</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : (GHC.Classes.Ord [a]) | v == $dOrd_a2xl}</span><span class='hs-conid'>Set.fromList</span></a> <a class=annot href="#"><span class=annottext>[[a]]</span><span class='hs-keyglyph'>[</span></a><a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>d</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>s1</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>s2</span></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>s1</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == sts##a2br
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>sts</span></a><span class='hs-layout'>,</span> <span class='hs-varid'>s2</span> <span class='hs-keyglyph'>&lt;-</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == sts##a2br
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>sts</span></a><span class='hs-layout'>,</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>s1</span></a> <span class='hs-varop'>&lt;</span> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>s2</span></a><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>181: </span>  <span class='hs-keyword'>where</span>
<span class=hs-linenum>182: </span>    <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>sts</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>x1:(Data.Set.Internal.Set a) -&gt; {v : [a] | x1 == listElts v}</span><span class='hs-conid'>Set.toList</span></a> <span class='hs-varop'>$</span> <a class=annot href="#"><span class=annottext>(Data.Set.Internal.Set a)</span><span class='hs-varid'>states</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == m##a2bq}</span><span class='hs-varid'>m</span></a>
<span class=hs-linenum>183: </span>    <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; [b]</span><span class='hs-varid'>d</span></a> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>a -&gt; a -&gt; [b]</span><span class='hs-varid'>distinguish</span></a> <a class=annot href="#"><span class=annottext>{v : a b c | v == m##a2bq}</span><span class='hs-varid'>m</span></a>
</pre>
</body>
</html>